- [Что такое state/состояние](#Что-такое-состояние)
- [Как ведет себя обычная локальная переменная в компоненте](#Локальная-переменная)
- [Что такое хуки](#Что-такое-хуки)
- [Правила хуков](#Правила-хуков)
- [Синтаксис useState](#Синтаксис-useState)
- [Как работает useState по шагам на примере](#Как-работает-useState-по-шагам-на-примере)
- [Нескольких переменных состояния в одном компоненте](#Нескольких-переменных-состояния-в-одном-компоненте)
- [Принцип работы хуков](#Принцип-работы-хуков)
- [Изолированность и закрытость состояния](#Изолированность-и-закрытость-состояния)
- [Одно состояние для нескольких компонентов](#Одно-состояние-для-нескольких-компонентов)

# Что такое состояние

Компоненты часто должны изменять то, что отображается на экране в результате взаимодействия. Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" в карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" должно поместить товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая специфическая для компонентов память называется _state_.

## Локальная переменная

[Перед вами компонент, который отображает количество нажатий на кнопку](https://codesandbox.io/p/sandbox/state-counter-local-var-kxq596):

```jsx
let count = 0;

const handleClick = () => (count = count + 1);

return <button onClick={handleClick}>{count}</button>;
```

Обработчик события `handleClick` обновляет локальную переменную `count`.

Но две вещи не позволяют увидеть это изменение при клике на кнопке(Какие?):

1. **Локальные переменные не сохраняются между рендерами.** Когда React рендерит этот компонент во второй раз, он рендерит его с нуля - он не учитывает никаких изменений в локальных переменных.
2. **Изменения локальных переменных не вызывают рендеринга.** React не понимает, что ему нужно снова рендерить компонент с новыми данными.

Чтобы обновить компонент новыми данными, должны произойти две вещи:

1. **Сохранить** данные между рендерами.
2. **Триггер** React для рендеринга компонента с новыми данными (повторный рендеринг).

Хук `useState` обеспечивает эти две вещи:

1. Переменная `состояния`/`state` для сохранения данных между рендерами.
2. Функция `установки состояния`/`state setter` для обновления переменной и запуска React для повторного рендеринга компонента.

[Добавляем переменную состояние в `<Counter />`](https://codesandbox.io/p/sandbox/state-counter-usestate-kmqqvm):

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => setCount(count + 1);

  return <button onClick={handleClick}>{0}</button>;
}
```

## Что такое хуки

В React функция `useState`, как и любая другая, начинающаяся с `use`, называется хуком.

_Хуки_ - это:

- специальные функции,
- которые доступны только во время рендеринга
- они позволяют вам `подключаться` к различным функциональным возможностям React.

## Правила хуков

**Функции-хуки, начинающиеся с `use`, могут вызываться только на верхнем уровне ваших компонентов или в ваших собственных хуках** Вы не можете вызывать хуки внутри условий, циклов или других вложенных функций. Вы `используете` функции React в верхней части вашего компонента, подобно тому, как вы `импортируете` модули в верхней части вашего файла.

## Синтаксис useState

Когда вы вызываете `useState`, вы говорите React, что хотите, чтобы этот компонент что-то запомнил:

```js
const [count, setCount] = useState(0);
```

В данном случае вы хотите, чтобы React запомнил `count`.

Принято называть эту пару так: `const [something, setSomething]`. Вы можете назвать ее как угодно, но соглашения облегчают понимание в разных проектах.

Единственным аргументом для `useState` является **начальное значение** вашей переменной состояния. В этом примере начальное значение `count` установлено в `0` с помощью `useState(0)`.

При каждом рендеринге компонента `useState` выдает массив, содержащий два значения:

1. Переменная **state** (`count`) со значением, которое вы сохранили.
2. Функция **установки состояния** (`setCount`), которая может обновить переменную состояния и вызвать React для повторного рендеринга компонента.

## Как работает useState по шагам на примере

Вот как это происходит в действии:

```js
const [count, setCount] = useState(0);
```

1. **Первоначальный рендер компонента** Поскольку вы передали `0` в `useState` в качестве начального значения для `count`, он вернет `[0, setCount]`. React помнит, что `0` - это последнее значение состояния.
2. **Вы обновляете состояние.** Когда пользователь нажимает на кнопку, вызывается `setCount(count + 1)`. `count` - это `0`, поэтому вызывается `setCount(1)`. Это указывает React на то, что `count` теперь `1`, и запускает еще один рендер.
3. **Второй рендер вашего компонента.** React по-прежнему видит `useState(0)`, но поскольку React _помнит_, что вы установили `count` в `1`, он возвращает `[1, setCount]` вместо этого.
4. И так далее!

Синтаксис [ и ] здесь называется **деструктуризация** массива и позволяет считывать значения из массива. Массив, возвращаемый функцией `useState` всегда содержит ровно два элемента.
Это просто короткий вариант записи:

```js
let [firstName, surname] = arr;
// или
let firstName = arr[0];
let surname = arr[1];
```

## Нескольких переменных состояния в одном компоненте

В одном компоненте может быть сколько угодно переменных состояния разных типов.

[В этом компоненте есть две переменные состояния, числа X и Y.](https://codesandbox.io/p/sandbox/state-few-states-wrong-4grql4)

```jsx
function Position() {
  const [x, setX] = useState(10);
  const [y, setY] = useState(20);

  return (
    <div
      onPointerMove={(e) => {
        setX(e.clientX);
        setY(e.clientY);
      }}
    >
      Position: (x: {x}, y: {y})
    </div>
  );
}
```

Хорошо иметь `НЕСКОЛЬКО` переменных состояния, если их состояния `НЕ` связаны между собой

И если вы обнаружите, что часто изменяете две переменные состояния вместе, [как `x` и `y` в нашем примере, возможно, будет проще объединить их в одну](https://codesandbox.io/p/sandbox/state-uniq-state-fzl4tp)

```jsx
function Position() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  return (
    <div
      onPointerMove={(e) => {
        setPosition({ x: e.clientX, y: e.clientY });
      }}
    >
      Position: (x: {position.x}, y: {position.y})
    </div>
  );
}
```

Например, если у вас есть форма с большим количеством полей, удобнее иметь одну переменную состояния, которая содержит объект, чем переменную состояния для каждого поля(ddd).

## Принцип работы хуков

Вы, наверное, заметили, что вызов `useState` не получает никакой информации о том, _к какой_ переменной состояния он обращается. Нет никакого "идентификатора", который передается `useState`, так как же он узнает, какую из переменных состояния нужно вернуть? Полагается ли он на какую-то магию вроде разбора ваших функций? Ответ - нет.

Вместо этого, чтобы обеспечить лаконичный синтаксис, хуки **опираются на стабильный порядок вызова при каждом рендере одного и того же компонента.** Это хорошо работает на практике, потому что если вы следуете правилу выше ("вызывать хуки только на верхнем уровне"), хуки всегда будут вызываться в одном и том же порядке.

<details><summary>Понимать</summary>
[Кроме того, плагин [linter plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) отлавливает большинство ошибок.]
</details>

Внутри React хранит:

- массив пар состояний для каждого компонента
- индекс текущей пары, который устанавливается в `0` перед рендерингом.

_Каждый раз, когда вы вызываете `useState`, React предоставляет вам следующую пару состояний и увеличивает индекс._

## Изолированность и закрытость состояния

Состояние локально для экземпляра компонента на экране: **если вы отобразите один и тот же компонент дважды, каждая копия будет иметь полностью изолированное состояние!**. Изменение одного из них не повлияет на другой.

[Здесь отображено два компонента `<Counter />` и их состояния хранится отдельно.](https://codesandbox.io/p/sandbox/state-isolate-and-private-3g89cd). Попробуйте нажать на кнопки внутри каждого. Обратите внимание, что их состояние независимо.

```jsx
function Page() {
  return (
    <>
      <Counter />
      <Counter />
    </>
  );
}
```

Также обратите внимание, что:

- компонент `<Page />` ничего не "знает" о состоянии `<Counter />` и даже о том, есть ли оно у него
- в отличие от `props`, **state полностью приватно для объявившего его компонента.**

Родительский компонент не может изменить состояние дочернего `<Counter />`. Это позволяет добавлять состояние в любой компонент или удалять его без влияния на остальные компоненты.

## Одно состояние для нескольких компонентов

Что, если вы хотите, чтобы оба `<Counter />`-а синхронизировали свои состояния?

[Правильный способ сделать это в React](https://codesandbox.io/p/sandbox/state-shared-klmkjr):

- _удалить_ состояние из _дочерних компонентов_;
- и _добавить_ его в их _ближайший общий родитель_.

```jsx
function Counter({ count, onClick }) {
  return <button onClick={onClick}>{count}</button>;
}

function Page() {
  const [count, setCount] = useState(0);
  const handleClick = () => setCount(count + 1);
  return (
    <>
      <Counter count={count} onClick={handleClick} />
      <Counter count={count} onClick={handleClick} />
    </>
  );
}
```
