# Реакция на события

React позволяет добавлять _обработчики событий_ в JSX. Обработчики событий - это ваши собственные функции, которые будут запускаться в ответ на такие действия, как нажатие, наведение курсора, фокусировка ввода формы и так далее.

## Добавление обработчиков событий

Чтобы добавить обработчик событий, сначала определите функцию, а затем передайте ее в качестве свойства в соответствующий JSX-тег.

```jsx
export default function Button() {
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

Функции обработчика событий:

- Обычно определяются _внутри_ ваших компонентов.
- Имеют имена, начинающиеся с `handle`, за которым следует имя события.
- Функции, передаваемые обработчикам событий, должны передаваться, а не вызываться

| передача функции (правильно)     | вызов функции (неправильно)        |
| -------------------------------- | ---------------------------------- |
| `<button onClick={handleClick}>` | `<button onClick={handleClick()}>` |

Разница едва заметна. В первом примере функция `handleClick` передается в качестве обработчика события `onClick`. Это указывает React запомнить ее и вызывать вашу функцию только тогда, когда пользователь нажмет на кнопку.

Во втором примере `()` в конце `handleClick()` запускает функцию _непосредственно_ во время [рендеринга](/learn/render-and-commit), без каких-либо щелчков. Это происходит потому, что JavaScript внутри [JSX `{` и `}`](/learn/javascript-in-jsx-with-curly-braces) исполняется сразу же.

Если передать такой встроенный код, то он будет срабатывать не по щелчку, а при каждом рендеринге компонента.

Поскольку обработчики событий объявляются внутри компонента, они имеют доступ к его параметрам.

### Передача обработчиков событий в качестве пропсов

Часто требуется, чтобы родительский компонент указывал дочерний обработчик события. Например, в зависимости от того, где вы используете компонент `Button`, вы можете захотеть выполнить разные функции - возможно, одна воспроизводит фильм, а другая загружает изображение.

Для этого в качестве обработчика события передайте компоненту параметр, полученный от родителя.

# Состояние: Память Компонента

Компоненты часто должны изменять то, что отображается на экране в результате взаимодействия. Ввод текста в форму должен обновить поле ввода, нажатие кнопки "next" в карусели изображений должно изменить отображаемое изображение, нажатие кнопки "buy" должно поместить товар в корзину. Компоненты должны "запоминать" вещи: текущее значение ввода, текущее изображение, корзину. В React такая специфическая для компонентов память называется _state_.

---

Перед вами компонент, который отображает количество нажатий на кнопку

Обработчик события handleClick обновляет локальную переменную count

Но две вещи не позволяют увидеть это изменение при клике на кнопке:

? Какие

Но две вещи не позволяют увидеть это изменение:

1 Локальные переменные не сохраняются между рендерами. Когда React рендерит этот компонент во второй раз, он рендерит его с нуля - он не учитывает никаких изменений в локальных переменных.
2 Изменения локальных переменных не вызывают рендеринга. React не понимает, что ему нужно снова рендерить компонент с новыми данными.

Чтобы обновить компонент новыми данными, должны произойти две вещи:

1. Сохранить данные между рендерами.
2. Триггер React для рендеринга компонента с новыми данными (повторный рендеринг).

Хук useState обеспечивает эти две вещи:

Переменная состояния для сохранения данных между рендерами.
Функция установки состояния для обновления переменной и запуска React для повторного рендеринга компонента.

---

Знакомимся с вашим первым хуком

В React функция useState, как и любая другая, начинающаяся с “use”, называется хуком.

Хуки - это:

- специальные функции,
- которые доступны только во время рендеринга React.
- Они позволяют вам “подключаться” к различным функциональным возможностям React.

Ошибки
Функции-хуки, начинающиеся с use, могут вызываться только на верхнем уровне ваших компонентов или в ваших собственных хуках Вы не можете вызывать хуки внутри условий, циклов или других вложенных функций. Вы “используете” фичи/возможности(features) React (функциональность реакт) в верхней части вашего компонента, подобно тому, как вы “импортируете” модули в верхней части вашего файла.

Когда вы вызываете useState, вы говорите React, что хотите, чтобы этот компонент что-то запомнил:
В данном случае вы хотите, чтобы React запомнил count.

- Единственным аргументом для useState является начальное значение вашей переменной состояния.
  При каждом рендеринге компонента useState выдает массив, содержащий два значения:

1. Переменная state (count) со значением, которое вы сохранили.
2. Функция установки состояния (setCount), которая может обновить переменную состояния и вызвать React для повторного рендеринга компонента.

- Синтаксис [ и ] здесь называется деструктуризация массива и позволяет считывать значения из массива. Массив, возвращаемый функцией useState, всегда содержит ровно два элемента.
  Это просто короткий вариант записи:
  // let [firstName, surname] = arr;
  let firstName = arr[0];
  let surname = arr[1];

Принято называть эту возвращаемую пару так: const [something, setSomething]. [Вы можете назвать ее как угодно, но соглашения облегчают понимание в разных проектах.]

1. Первоначальный рендер вашего компонента. Поскольку вы передали 0 в useState в качестве начального значения для count, он вернет [0, setCount]. React помнит, что 0 - это последнее значение состояния.
2. Вы обновляете состояние. Когда пользователь нажимает на кнопку, вызывается setCount(count + 1). count - это 0, поэтому вызывается setCount(1) [с аргументом 1]. Это указывает React на то, что count теперь 1, и запускает еще один рендер.
3. Второй рендер вашего компонента. React по-прежнему видит useState(0), но поскольку React помнит, что вы установили count в 1, он возвращает [1, setCount] вместо этого.

---

Как React узнает, какое состояние нужно вернуть?

Вы, наверное, заметили, что вызов useState не получает никакой информации о том, к какой переменной состояния он обращается. Нет никакого “идентификатора”, который передается useState, так как же он узнает, какую из переменных состояния нужно вернуть?

Чтобы обеспечить лаконичный синтаксис, хуки опираются на стабильный порядок вызова при каждом рендере одного и того же компонента. Это хорошо работает на практике, потому что если вы следуете правилу выше (“вызывать хуки только на верхнем уровне”), хуки всегда будут вызываться в одном и том же порядке.

Внутри React хранит массив пар состояний для каждого компонента. Он также хранит индекс текущей пары, который устанавливается в 0 перед рендерингом. Каждый раз, когда вы вызываете useState, React предоставляет вам следующую пару состояний и увеличивает индекс. Подробнее об этом механизме можно прочитать в React Hooks: Not Magic, Just Arrays.

---

Состояние изолированное и закрытое

Состояние локально для экземпляра компонента на экране.

- Другими словами, если вы отобразите один и тот же компонент дважды,
- каждая копия будет иметь полностью изолированное состояние! (свой count)
- Изменение одного из них не повлияет на другой.

?(Именно этим состояние отличается от обычных переменных. Состояние не привязано к определенному вызову функции или месту в коде)
Состояние “локально” для конкретного места на экране.

Вы отобразили два компонента <Counter />, поэтому их состояние хранится отдельно.

Также обратите внимание, что компонент Page ничего не “знает” о состоянии <Counter /> и даже о том, есть ли оно у него.

В отличие от props, state полностью приватно для объявившего его компонента. Родительский компонент не может его изменить. Это позволяет добавлять состояние в любой компонент или удалять его без влияния на остальные компоненты.

Что, если вы хотите, чтобы оба Counter-а синхронизировали свои состояния?

Правильный способ сделать это в React - удалить состояние из дочерних компонентов и добавить его в их ближайший общий родитель.

---

Рендеринг и фиксация / Render and commit

Прежде чем ваши компоненты будут отображены на экране, они должны быть отрендерены React. Понимание этапов этого процесса поможет вам продумать выполнение вашего кода, и объяснить его поведение.

Этот процесс состоит из трёх этапов:

1. Триггер/запуск рендера
2. Рендеринг компонента
3. Коммит/фиксация в DOM

Рассмотрим все эти этапы

Шаг 1: Запуск рендеринга

Существует два причины, по которым компонент рендериться:

1. Это первоначальный рендеринг компонента.
2. Состояние компонента (или одного из его предков) обновилось.

- Первоначальный рендеринг

Когда ваше приложение запускается, необходимо вызвать начальный рендеринг. Фреймворки и песочницы иногда скрывают этот код, но он выполняется вызовом createRoot с назначенным узлом DOM, а затем вызовом его метода render с вашим компонентом

Попробуйте закомментировать вызов root.render() и увидите, как компонент исчезнет!

- Рендеринг при обновлении состояния

После того как компонент был первоначально отрендерин, вы можете вызывать последующие рендеры, обновляя его состояние с помощью функции set(в нашем пример это setCount). Обновление состояния компонента автоматически ставит его в очередь на рендеринг.

Шаг 2: React рендерит ваши компоненты

После запуска рендеринга React вызывает ваши компоненты, чтобы определить, что отобразить на экране. “Рендеринг” - это вызов ваших компонентов React-ом (обращение React-а к вашим компонентам)

При первичном рендере React вызовет корневой компонент.
При последующих рендерах React будет вызывать функцию компонента, обновление состояния которого вызвало рендер.

Этот процесс рекурсивен: если обновленный компонент вернет какой-то другой компонент, React отрендерит этот компонент следующим, и если этот компонент тоже что-то вернет, он отрендерит этот компонент следующим, и так далее. Процесс будет продолжаться до тех пор, пока не останется ни одного вложенного компонента и React не будет точно знать, что должно быть отображено на экране.

- При первоначальном рендере React создаст DOM-узлы для тегов <section>, <h1> и трех <img>.
- Во время повторного рендеринга React вычислит, какие из их свойств, если таковые имеются, изменились с момента предыдущего рендеринга. Он ничего не будет делать с этой информацией до следующего шага, фазы коммита/фиксации.

---

Шаг 3: React фиксирует изменения в DOM

После рендеринга (вызова) ваших компонентов React изменяет DOM.

- Для первоначального рендеринга React будет использовать API DOM appendChild(), чтобы поместить все созданные им узлы DOM на экран.
- При повторном рендеринге React применит минимально необходимые операции (вычисляемые во время рендеринга!), чтобы DOM соответствовал последнему выводу рендеринга.

React изменяет узлы DOM только в случае разницы между рендерами.

Например, вот компонент, который каждую секунду рендерится с разными props, передаваемыми от родителя. Обратите внимание, что вы можете добавить текст в <input>, обновляя его value, но текст не исчезает при повторном рендеринге компонента:

Это работает, потому что во время последнего шага React только обновляет содержимое <h1> с новым временем. Он видит, что <input> появляется в JSX в том же месте, что и в прошлый раз, поэтому React не трогает <input> или его value! (eng)

\*Отрисовка в браузере

После того как рендеринг завершен и React обновил DOM, браузер перерисует экран. Хотя этот процесс известен как “браузерный рендеринг”, мы будем называть его “отрисовкой”, чтобы избежать путаницы в документации.
